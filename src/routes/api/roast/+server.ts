import { json, error } from '@sveltejs/kit';
import { jsonrepair } from 'jsonrepair';
import { generateRoast } from '$lib/server/llm';
import { withRateLimit } from '$lib/server/ratelimit';
import type { RequestHandler } from './$types';

const ARCHETYPE_DEFINITIONS = `
1. Renaissance Gatekeeper (文艺复兴守门员): Pre-1990s snob. Black & white films. Hates modern pop. Tag: #TimeTraveler #OldSchool
2. Cyber Ascetic (赛博苦行僧): Tarkovsky, Bela Tarr. 3h+ movies. Suffering = Art. Tag: #Masochist #BoringIsDeep
3. Midnight Heartbreak (午夜心碎鉴赏家): Wong Kar-wai, Murakami. Late night posts. Emo. Tag: #EmoKing #Lonely
4. Normie Mimic (现充模仿者): Blockbusters, Best-sellers. Safe taste. AI training data. Tag: #NPC #Basic
5. Spiritual New Yorker (精神纽约客): Woody Allen, Jazz, Modern Art. Pretends to be elite. Tag: #FakeElite #Posh
6. Otaku Fundamentalist (二次元原教旨主义者): Anime/Manga only. 2D > 3D. Seiyuu nerd. Tag: #Weeb #2D4Life
7. Digital Pickle (电子榨菜批发商): Friends, Sitcoms, Rewatching same shows 100x. Comfort zone. Tag: #ComfortBinge #SafeZone
8. Adrenaline Junkie (肾上腺素瘾君子): Horror, Crime, Gore. Needs stimulation. Tag: #GoreHound #ThrillSeeker
9. Internet Bodhisattva (互联网活菩萨): Rates everything 4-5 stars. Never hates. Tag: #TooNice #FakeNice
10. Schizophrenic Omnivore (精神分裂的杂食怪): Bergman + TikTok. High art + Trash. Chaos. Tag: #ChaosEnergy #Random
11. Fandom Guardian (饭圈守护神): Idols. Rate by face. "Brother is working hard". Tag: #FanGirl #DataWorker
12. Self-Help Junkie (成功学韭菜): "Rich Dad Poor Dad". Hustle culture. Wants to get rich via books. Tag: #Hustler #Leek
13. Happy Weirdo (快乐怪胎): Stop-motion, Rick & Morty, cult classics. "Wtf" but happy. Tag: #Weirdo #FunChaos
`;

export const POST = withRateLimit(async ({ request }: { request: Request }) => {
  const { interests, apiKeys } = await request.json();

  if (!interests || !Array.isArray(interests)) {
    throw error(400, 'Invalid data');
  }

  // Minimal data for prompt to save tokens
  const interestes_ = interests.map((item: any) => ({
    t: item.title,
    r: item.rating,
    g: item.tags,
    c: item.comment,
    d: item.create_time?.slice(0, 10), // Date only
  }));

  const prompt = `
    Role: Mean, cynical, humorous pop culture critic. Style: "Poisonous Tongue" (毒舌).
    Task: Roast this Douban user's taste.

    User Data:
    ${JSON.stringify(interestes_)}
    
    Archetypes:
    ${ARCHETYPE_DEFINITIONS}

    Rules:
    1. Identify archetype from list. BUT: If user doesn't fit perfectly, YOU MUST INVENT a new witty 4-6 char Chinese title (e.g. "烂片考古学家"). Creativity is preferred.
    2. Roast: Brutal, specific, funny. 300+ chars. Analyze 5-axis: pretentiousness, mainstream, nostalgia, darkness, geekiness.
    3. Tags: 3-4 punchy tags.
    4. Item Analysis: Pick 30 interesting items. Comment (thought) must be spicy/insightful (20-40 chars text).

    Output JSON:
    {
      "archetype": "Name",
      "roast": "Content...",
      "tags": ["Tag1", "Tag2"],
      "scores": { "pretentiousness": 0-100, "mainstream": 0-100, "nostalgia": 0-100, "darkness": 0-100, "geekiness": 0-100 },
      "item_analysis": [{ "title": "Exact Title", "thought": "Roast" }]
    }
  `;

  try {
    const llmResult = await generateRoast(prompt, apiKeys);
    const text = llmResult.text;
    console.log(`[Roast] Generated by ${ llmResult.model }`);

    // Clean up markdown code blocks if present
    let cleanText = text.replace(/```json/g, '').replace(/```/g, '').trim();

    // Robust JSON extraction: Find first '{' and count braces to find matching '}'
    const firstOpen = cleanText.indexOf('{');
    let extractedJSON = null;

    if (firstOpen !== -1) {
      let balance = 0;
      for (let i = firstOpen;i < cleanText.length;i++) {
        if (cleanText[i] === '{') balance++;
        else if (cleanText[i] === '}') balance--;

        if (balance === 0) {
          extractedJSON = cleanText.substring(firstOpen, i + 1);
          break;
        }
      }
    }

    // Fallback: If structure is broken, try the old greedy method or just use the whole text if it looks like JSON
    if (!extractedJSON) {
      const lastClose = cleanText.lastIndexOf('}');
      if (firstOpen !== -1 && lastClose !== -1 && lastClose > firstOpen) {
        extractedJSON = cleanText.substring(firstOpen, lastClose + 1);
      } else {
        extractedJSON = cleanText;
      }
    }

    let finalJSON;
    try {
      finalJSON = JSON.parse(jsonrepair(extractedJSON));
    } catch (e) {
      // Fallback: Try to fix "Shell-style" comments (#) which some LLMs hallucinate
      // We only do this if normal repair fails, to avoid corrupting valid strings containing #
      console.warn('JSON repair failed, trying aggressive comment cleanup...');
      const patched = extractedJSON.replace(/, #/g, ', //');
      finalJSON = JSON.parse(jsonrepair(patched));
    }

    return json({
      ...finalJSON,
      model: llmResult.model
    });
  } catch (e) {
    console.error('Gemini Roast Error:', e);
    throw error(500, 'Failed to generate roast');
  }
});
